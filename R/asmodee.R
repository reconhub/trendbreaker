#' Automatic Selection of Models Outlier DEtection for Epidemics (ASMODEE)
#'
#' This function implements an algorithm for epidemic time series analysis in
#' aim to detect recent deviation from the trend followed by the data. Data is
#' first partitioned into 'recent' data, using the last `k` observations as
#' supplementary individuals, and older data used to fit the
#' trend. Trend-fitting is done by fitting a series of user-specified models for
#' the time series, with different methods for selecting best fit (see details,
#' and the argument `method`). The prediction interval is then calculated for
#' the best model, and every data point (including the training set and
#' supplementary individuals) falling outside are classified as 'outliers'. The
#' value of `k` can be fixed by the user, or automatically selected to minimise
#' outliers in the training period and maximise and the detection of outliers in
#' the recent period.
#'
#' @details Automatic model selection is used to determine the model best
#'   fitting the training data from a list of user-provided models. First, all
#'   models are fitted to the data. Second, models are selected using the
#'   approach specified by the `method` argument. The default,
#'   [`evaluate_resampling`](evaluate_resampling), uses cross-validation
#'   (10-fold by default) and root mean squared error (RMSE) to assess model
#'   fit. This approach is likely to select models with good predictive
#'   abilities, but is computationally intensive. The alternative is using
#'   [`evaluate_aic`](evaluate_aic), which uses Akaike's Information Criteria to
#'   assess model fit penalised by model complexity. This approach is fast, but
#'   only measures model fit rather than predictive ability.
#'
#' @author Thibaut Jombart and Dirk Schumacher, with inputs from Michael HÃ¶hle,
#'   Mark Jit, John Edmunds, Andre Charlett
#'
#' @export
#'
#' @param data A `data.frame` or a `tibble` containing the response and
#'   explanatory variables used in the `models`.
#'
#' @param models A list of [`trendbreaker_model`](trendbreaker_model) objects,
#'   generated by `lm_model`, `glm_model`, `glm_nb_model`, `brms_model` and
#'   similar functions (see `?trendbreaker_model`) for details.
#'
#' @param alpha The alpha threshold to be used for the prediction interval
#'   calculation; defaults to 0.05, i.e. 95% prediction intervals are
#'   calculated.
#'
#' @param max_k An `integer` indicating the maximum number of recent data points
#'   to be excluded from the trend fitting procedure. By default, ASMODEE will
#'   look for a changepoint within this recent time period, after which data no
#'   longer fit the previous trend. Larger values will require more computation
#'   from the method. Only used if `fixed_k` is `NULL`.
#'
#' @param fixed_k An optional `integer` indicating the number of recent data points to be
#'   excluded from the trend fitting procedure. Defaults to `NULL`, in which
#'   case ASMODEE detects `k` automatically, at the expense of computational
#'   time.
#'
#' @param method A function used to evaluate model fit. Current choices are
#'   `evaluate_resampling` (default) and `evaluate_aic`. `evaluate_resampling`
#'   uses cross-validation and RMSE to assess model fit. `evaluate_aic` uses
#'   Akaike's Information Criterion instead, which is faster but possibly less
#'   good a selecting models with the best predictive power.
#'
#' @param ... Further arguments passed to `method`.
#'
#' @return An `trendbreaker` object (S3 class inheriting `list`), containing items
#'   which can be accessed by various accessors - see `?trendbreaker-accessors`
#'
#' @examples
#'
#' if (require(cowplot) && require(tidyverse) && require(trending)) {
#'   # load data
#'   data(nhs_pathways_covid19)
#'
#'   # select last 28 days
#'   first_date <- max(nhs_pathways_covid19$date, na.rm = TRUE) - 28
#'   pathways_recent <- nhs_pathways_covid19 %>%
#'     filter(date >= first_date)
#'
#'   # define candidate models
#'   models <- list(
#'     regression = lm_model(count ~ day),
#'     poisson_constant = glm_model(count ~ 1, family = "poisson"),
#'     negbin_time = glm_nb_model(count ~ day),
#'     negbin_time_weekday = glm_nb_model(count ~ day + weekday)
#'   )
#'
#'   # analyses on all data
#'   counts_overall <- pathways_recent %>%
#'     group_by(date, day, weekday) %>%
#'     summarise(count = sum(count))
#'
#'   # results with automated detection of 'k'
#'   res_overall <- asmodee(counts_overall, models, method = evaluate_aic)
#'   res_overall
#'   plot(res_overall, "date")
#'
#'   # results with fixed value of 'k' (7 days)
#'   res_overall_k7 <- asmodee(counts_overall, models, fixed_k = 7)
#'   plot(res_overall_k7, "date")
#'
#'   # analyses by NHS regions
#'   counts_nhs_region <- pathways_recent %>%
#'     group_by(nhs_region, date, day, weekday) %>%
#'     summarise(count = sum(count)) %>%
#'     complete(date, fill = list(count = 0)) %>%
#'     split(.$nhs_region)
#'
#'   res_nhs_region <- lapply(counts_nhs_region,
#'                            asmodee,
#'                            models,
#'                            method = evaluate_aic,
#'                            alpha = 0.05)
#'
#'   plots_nhs_region <- lapply(seq_along(res_nhs_region),
#'                              function(i)
#'                                plot(res_nhs_region[[i]], "date", point_size = 1, guide = FALSE) +
#'                                  labs(subtitle = names(res_nhs_region)[i], x = NULL))
#'   cowplot::plot_grid(plotlist = plots_nhs_region)
#'
#' }
#'
asmodee <- function(data, models, alpha, max_k, fixed_k, method, ...) {
  UseMethod("asmodee", data)
}

#' @export
asmodee.data.frame <- function(data,
                               models,
                               alpha = 0.05,
                               max_k = 7,
                               fixed_k = NULL,
                               method = trending::evaluate_resampling,
                               ...) {

  n <- nrow(data)

  ## There are two modes for this function:
  ## 1. (default) auto-detection of the value of 'k', in which case we use the
  ## `detect_changepoint` routine to select the 'best' value of `k`
  ## 2. use a user-specified value of `k`, passed through the `fixed_k` argument

  if (is.null(fixed_k)) {
    res_changepoint <- detect_changepoint(
      data = data,
      models = models,
      alpha = alpha,
      max_k = max_k,
      method = method,
      ...
    )
    selected_model <- res_changepoint$model
    selected_k <- res_changepoint$k
  } else {
    if (!is.numeric(fixed_k) |
          !is.finite(fixed_k)) {
      msg <- "`fixed_k` must be a finite number"
      stop(msg)
    }
    k <- as.integer(max(fixed_k, 0L))
    n_train <- n - k
    data_train <- data[seq_len(n_train), ]
    selected_model <- trending::select_model(data = data_train,
                                   models = models,
                                   method = method,
                                   ...)$best_model
    selected_model <- trending::fit(selected_model,data_train)
    selected_k <- k
  }


  ## find outliers
  res_outliers <- detect_outliers(data = data,
                                  model = selected_model,
                                  alpha = alpha)


  ## form output
  n_train <- n - selected_k
  n_outliers <- sum(res_outliers$outlier, na.rm = TRUE)
  n_outliers_recent <- sum(utils::tail(res_outliers$outlier, selected_k), na.rm = TRUE)
  n_outliers_train <-  n_outliers - n_outliers_recent
  p_value <- stats::pbinom(n_outliers,
                           size = n,
                           prob = alpha,
                           lower.tail = FALSE)

  out <- list(
    k = selected_k,
    model = selected_model,
    n_outliers = n_outliers,
    n_outliers_train = n_outliers_train,
    n_outliers_recent = n_outliers_recent,
    p_value = p_value,
    results = res_outliers
  )
  class(out) <- c("trendbreaker", class(out))
  out
}

#' @export
asmodee.incidence2 <- function(data,
                               models,
                               alpha = 0.05,
                               max_k = 7,
                               fixed_k = NULL,
                               method = trending::evaluate_resampling,
                               ...) {
  # check incidence2 package is present
  check_suggests("incidence2")

  groups <- incidence2::get_group_names(data)
  if (!is.null(groups)) {
    f_groups <- lapply(suppressMessages(data[groups]), factor, exclude = NULL)
    split_dat <- split(data, f_groups, sep = "-")
  } else {
    split_dat = list(data)
  }

  out <- lapply(split_dat,
                function(x) {
                  x <- suppressMessages(as.data.frame(x))
                  asmodee(
                    x,
                    models = models,
                    method = method,
                    alpha = alpha,
                    fixed_k = fixed_k,
                    ...)
                })

  names(out) <- names(split_dat)
  class(out) <- "trendbreaker_incidence2"
  out
}


